# Технологический стек Kii Health Mobile — Текстовое описание

## Введение

Kii Health Mobile построено на современных, проверенных в production технологиях, которые обеспечивают высокую производительность, надежность и безопасность. Приложение использует гибридный подход, сочетая лучшие практики мобильной и backend разработки.

---

## 1. Backend: Project Fusion Microservices

### Java 17 и Quarkus Framework

Backend Kii Health Mobile строится на основе Project Fusion — набора Java микросервисов, разработанных с использованием Java 17 и Quarkus фреймворка.

**Java 17** — это модерн версия Java, которая обеспечивает улучшенную производительность, лучшую управляемость памяти и встроенную поддержку современных языковых конструкций. Java была выбрана для backend'а потому что является самым надежным и проверенным решением для enterprise приложений в сфере здравоохранения.

**Quarkus** — это облачно-ориентированный (cloud-native) Java фреймворк, специально разработанный для микросервисной архитектуры. Основные преимущества Quarkus:

- Супер быстрый старт приложения (миллисекунды вместо секунд)
- Минимальное потребление памяти, что критично для cloud окружения
- Оптимизирован для контейнеризации в Docker и Kubernetes
- Идеален для serverless архитектур

**Maven** используется как инструмент управления сборкой и зависимостями. Это позволяет команде управлять версиями всех используемых библиотек, автоматизировать процесс сборки и публикации артефактов.

### Архитектура микросервисов

Project Fusion состоит из несколько взаимосвязанных микросервисов:

**Keycloak Authentication Server** — отдельный компонент, отвечающий за аутентификацию и авторизацию. Использует стандарты OAuth 2.0 и OpenID Connect с поддержкой PKCE (Proof Key for Public Clients). Поддерживает несколько realm'ов для разных окружений: fusion-test для разработки, fusion-staging для предпроизводства, и fusion-prod для production.

**Messaging Service** — микросервис, обрабатывающий отправку, получение и хранение сообщений между пользователями. Интегрирован с SQLite на мобильном устройстве для локального кеширования.

**Profile Service** — управляет профилями пациентов и их медицинскими данными. Предоставляет REST API для чтения и обновления информации.

**Integration Service** — обеспечивает интеграцию с внешними системами здравоохранения и данными.

**Dashboard Service** — предоставляет агрегированные данные и аналитику для главного экрана приложения.

Все микросервисы общаются друг с другом через REST API, используют общие библиотеки для безопасности и работы с данными, и развертываются независимо друг от друга в Kubernetes кластере.

---

## 2. Frontend: React Native и Expo

### React Native 0.79.5

Мобильное приложение разработано на **React Native** — JavaScript фреймворке для создания нативных iOS и Android приложений с единой кодовой базой. React Native позволяет:

- Писать код один раз и запускать его на обоих платформах
- Получить нативную производительность благодаря компиляции JavaScript кода в нативный
- Использовать JavaScript экосистему (npm, библиотеки) в мобильной разработке
- Быстро итерировать с помощью Hot Reload

### Expo SDK 53

**Expo** — это фреймворк и платформа, которая упрощает разработку с React Native:

- Предоставляет готовые компоненты и API без необходимости писать нативный код
- Позволяет запускать приложение на реальных устройствах для тестирования без сборки
- Обеспечивает Over-the-air обновления (пользователи получают обновления без переустановки из App Store)
- Упрощает управление сертификатами и provisioning profiles

### TypeScript

Весь код приложения написан на **TypeScript** — типизированном надмножестве JavaScript. TypeScript обеспечивает:

- Раннее обнаружение ошибок на этапе разработки
- Самодокументирующийся код через типы
- Отличную поддержку IDE с автодополнением
- Безопасность рефакторинга больших кодовых баз

### NativeWind (TailwindCSS)

Для стилизации используется **NativeWind** — утилитарный CSS фреймворк для мобильных приложений, основанный на TailwindCSS. Это позволяет:

- Быстро создавать интерфейсы, используя готовые классы для стилей
- Обеспечить консистентный дизайн через систему ограничений (spacing, colors, etc.)
- Минимизировать объем CSS кода и количество стилевых конфликтов
- Легко темизировать приложение (светлая/темная тема)

### Expo Router

**Expo Router** обеспечивает файловую маршрутизацию (file-based routing):

- Структура папок автоматически определяет структуру маршрутов приложения
- Поддержка глубоких ссылок (deep linking) из коробки
- Группы маршрутов без URL сегментов для организации кода
- Условная навигация на основе статуса аутентификации

### Управление состоянием

**React Query** используется для управления состоянием сервера (server state):

- Синхронизирует данные с backend'ом
- Автоматически повторяет запросы при ошибках
- Кеширует данные и обновляет их в фоне
- Автоматически обновляет токены перед их истечением

**Zustand** используется для управления локальным состоянием приложения (client state):

- Простой API для создания хранилищ состояния
- Поддержка персистентного хранилища (данные сохраняются между запусками)
- Интеграция с защищенным хранилищем (SecureStore) для чувствительных данных
- Минимальный вес и отличная производительность

---

## 3. Хранилища данных

### Local SQLite Database

На каждом мобильном устройстве работает **SQLite** база данных, которая обеспечивает:

- Полноценную работу приложения без интернета
- Локальное кеширование сообщений и вложений
- Быстрый доступ к часто используемым данным
- Синхронизацию с backend'ом при наличии соединения

### Secure Storage

Для хранения чувствительных данных используется **Expo Secure Store**:

- JWT токены (access и refresh токены) хранятся в защищенном хранилище ОС
- Биометрические данные защищены от несанкционированного доступа
- Учетные данные и пароли зашифрованы

**MMKV** — быстрое key-value хранилище используется для:

- Часто обновляемых данных (статус синхронизации, флаги функций)
- В 10 раз быстрее чем AsyncStorage
- Автоматическое шифрование данных

### REST API и Backend Databases

Основные данные (профили пользователей, медицинские записи, сообщения) хранятся в backend базах данных и доступны через REST API:

- User profiles и демографические данные
- Healthcare records и медицинская история
- Messages синхронизируются через API
- Analytics и статистические данные

---

## 4. Аутентификация и авторизация: Keycloak

### OAuth 2.0 с PKCE

Аутентификация в приложении осуществляется через **Keycloak** с использованием стандарта OAuth 2.0 и PKCE (Proof Key for Public Clients).

**Как это работает:**

1. Приложение генерирует случайную строку (code_verifier)
2. Создает хеш этой строки (code_challenge)
3. Открывает браузер с редиректом на Keycloak для входа
4. Пользователь вводит учетные данные в браузере
5. Keycloak возвращает authorization code
6. Приложение обменивает код на токены, используя code_verifier для подтверждения подлинности
7. Keycloak валидирует code_verifier и выдает access_token и refresh_token

**PKCE** — это дополнительный уровень безопасности, который предотвращает перехват authorization code злоумышленниками.

### Multi-Environment Support

Keycloak поддерживает несколько изолированных realm'ов для разных окружений:

- **fusion-test** — для разработки, с тестовыми пользователями и мягкими политиками
- **fusion-staging** — для предпроизводства, приближенное к production
- **fusion-prod** — для production, со строгими требованиями безопасности

Каждый realm имеет свой набор пользователей, OAuth клиентов и сертификатов. Мобильное приложение может быть собрано для любого окружения без изменения кода.

### Role-Based Access Control

Keycloak обеспечивает управление доступом на основе ролей (RBAC). JWT токен содержит роли пользователя:

```
{
  "sub": "user-id",
  "email": "user@example.com",
  "roles": ["patient", "messages-access", "live-chat-access"]
}
```

Мобильное приложение использует эти роли для условного рендеринга интерфейса:

- Если пользователь не имеет роли "messages-access", вкладка сообщений скрывается
- Если пользователь не имеет роли "live-chat-access", вкладка live chat не доступна
- Дополнительные функции доступны только пользователям с соответствующими ролями

### Управление токенами

Access token имеет время жизни 15 минут. Refresh token имеет время жизни 7 дней. Приложение:

- Хранит оба токена в защищенном хранилище
- Автоматически обновляет access token в фоне перед истечением
- При каждом API запросе добавляет access token в заголовок Authorization
- При получении ошибки 401 (token expired) автоматически обновляет токен и повторяет запрос
- При logout очищает оба токена и отзывает их на сервере

---

## 5. Infrastructure и Deployment

### Expo Application Services (EAS)

**EAS Build** обеспечивает облачную сборку приложения:

- Сборка iOS выполняется на Mac машинах в облаке (требуется для App Store)
- Сборка Android выполняется на Linux машинах
- EAS управляет сертификатами и provisioning profiles
- Создает подписанные APK и IPA пакеты, готовые к распространению

**EAS Submit** автоматизирует отправку в app stores:

- Отправляет iOS приложение в TestFlight для внутреннего тестирования
- Отправляет в App Store Connect для публикации в App Store
- Отправляет Android приложение в Google Play
- Управляет версиями, changelogs и метаданными

### Backend Infrastructure (CloudMD)

Project Fusion развертывается в **Kubernetes** кластере:

- Каждый микросервис работает в отдельном контейнере
- Kubernetes автоматически масштабирует сервисы на основе нагрузки
- Rolling updates позволяют обновлять сервисы без простоев
- Service discovery и load balancing встроены в Kubernetes

**CloudMD Platform** обеспечивает:

- Управляемую инфраструктуру оптимизированную для здравоохранения
- Соответствие стандартам HIPAA и другим требованиям конфиденциальности
- Geo-распределенное размещение для надежности и performance
- Monitoring, alerting и управление логами

### CI/CD Pipeline (GitHub Actions)

При каждом push в репозиторий автоматически запускается pipeline:

1. **Lint и Format Check** — проверка кода на соответствие стандартам
2. **TypeScript Compilation** — проверка типизации
3. **Unit Tests** — запуск модульных тестов
4. **Build iOS/Android** — облачная сборка через EAS
5. **Integration Tests** — тестирование интеграции компонентов
6. **Upload to TestFlight/Google Play** — отправка в тестовые каналы
7. **Deploy to Production** — развертывание (требует ручного одобрения)

### Distribution

**iOS**:

- TestFlight используется для внутреннего тестирования перед release
- App Store Connect управляет версиями и метаданными
- Приложение подписывается сертификатом Apple разработчика

**Android**:

- Google Play Internal Testing для QA команды
- Google Play для production distribution
- Приложение подписывается с использованием app signing key

---

## 6. Security Architecture

### Token Lifecycle Management

Приложение реализует полный lifecycle управления токенами:

**Получение токенов:**

- Пользователь входит через OAuth 2.0 flow
- Keycloak выдает access_token (15 минут) и refresh_token (7 дней)

**Безопасное хранение:**

- Оба токена сохраняются в Expo Secure Store (зашифрованное хранилище ОС)
- Никогда не сохраняются в обычном хранилище или AsyncStorage

**Использование токенов:**

- Access token отправляется в заголовке Authorization при каждом API запросе
- Если api возвращает 401, приложение автоматически обновляет токен

**Фоновое обновление:**

- React Query автоматически обновляет access token в фоне каждые 14 минут (перед истечением)
- При возобновлении приложения (app resume) также проверяется и обновляется token
- Это обеспечивает что user никогда не столкнется с expired token

**Logout:**

- При logout оба токена удаляются из Secure Store
- Токены отзываются на сервере Keycloak
- Пользователь перенаправляется на экран входа

### Inactivity Timeout

Приложение отслеживает активность пользователя:

- Если пользователь не взаимодействует с приложением более 15 минут
- И приложение перейдет в фоновый режим
- При возвращении в foreground приложение автоматически logout пользователя
- Это предотвращает несанкционированный доступ если устройство было украдено

### Biometric Authentication

Кроме стандартной аутентификации, приложение поддерживает биометрическую аутентификацию:

- Face ID на iPhone
- Touch ID на iPhone и iPad
- Fingerprint на Android устройствах

Биометрия не заменяет OAuth, а используется как быстрая переаутентификация при возобновлении сессии.

---

## 7. Архитектурные паттерны

### Service Layer Pattern

Приложение следует классическому архитектурному паттерну с разделением на слои:

- **UI Components** — React компоненты для рендеринга интерфейса
- **Hooks** — custom React hooks с бизнес логикой
- **Services** — классы/функции для общения с API (MessageService, ProfileService, и т.д.)
- **Axios Client** — HTTP клиент с interceptors для добавления токенов и обработки ошибок
- **REST APIs** — backend endpoints

Такое разделение обеспечивает separation of concerns и легче тестировать код.

### Store Pattern (Zustand)

Для управления локальным состоянием приложения используется Zustand:

```typescript
const useAuthStore = create(
  persist(
    (set) => ({
      tokens: null,
      userId: null,
      setTokens: (tokens) => set({ tokens }),
      logout: () => set({ tokens: null, userId: null })
    }),
    {
      name: "auth-storage",
      storage: secureStorage
    }
  )
);
```

Каждый store содержит:

- **State** — данные (токены, user info, loading flags)
- **Actions** — функции для изменения состояния
- **Persistence** — сохранение в локальное хранилище

### File-based Routing (Expo Router)

Маршруты в приложении определяются структурой файлов:

```
app/
├── _layout.tsx              # Root layout
├── (auth)/                  # Auth route group
│   ├── login.tsx
│   └── _layout.tsx
└── (main)/                  # Authenticated routes
    ├── (tabs)/              # Bottom tab navigation
    │   ├── (pillars)/       # Home tab
    │   ├── (messages)/      # Messages tab
    │   ├── (chat)/          # Live chat tab
    │   └── patient/         # Profile tab
    └── _layout.tsx
```

Такой подход обеспечивает:

- Интуитивную структуру маршрутов, отражающую структуру файлов
- Автоматическую генерацию маршрутов
- Глубокие ссылки из коробки

---

## 8. Development Workflow

### Окружение разработки

Разработчики могут запускать приложение для разных окружений:

```bash
# Development (локальный backend)
npm run prebuild:dev && npm run ios:dev

# Staging (staging backend)
npm run prebuild:stg && npm run ios:stg

# Production-like (production backend)
npm run ios:prod
```

Каждый вариант использует разные Keycloak realm'ы и API endpoints, но код остается неизменным.

### Environment Configuration

Конфигурация окружений централизована в одном файле:

```typescript
export const envConfig = {
  dev: {
    apiBaseURL: "http://localhost:8000",
    keycloakURL: "http://localhost:8080",
    realm: "fusion-test"
  },
  staging: {
    apiBaseURL: "https://api-staging.example.com",
    keycloakURL: "https://auth-staging.example.com",
    realm: "fusion-staging"
  },
  production: {
    apiBaseURL: "https://api.example.com",
    keycloakURL: "https://auth.example.com",
    realm: "fusion-prod"
  }
};
```

Это позволяет легко переключаться между окружениями без изменения логики приложения.

### Testing Strategy

Приложение использует несколько уровней тестирования:

- **Unit Tests (Jest)** — тестирование отдельных функций и компонентов
- **Component Tests (React Testing Library)** — тестирование React компонентов
- **E2E Tests (Cypress)** — тестирование полных пользовательских сценариев
- **Device Testing (EAS Device Farm)** — тестирование на реальных устройствах

---

## 9. Интеграции и внешние сервисы

### OpenAPI Code Generation

Backend предоставляет OpenAPI/Swagger спецификацию своих REST API. Мобильное приложение использует `openapi-generator` для автоматического генерирования TypeScript клиентов:

```bash
npm run generate:axios-client
```

Это обеспечивает:

- **Типизированные API клиенты** — вся логика работы с API имеет типы
- **Автоматическую документацию** — типы служат документацией
- **Синхронизацию с backend** — если backend изменил API, клиент обновляется автоматически
- **Быстрое обновление** — не нужно вручную писать HTTP запросы

### WebView Integration

Некоторые части приложения (live chat, rich media) встраивают WebView компоненты:

- Позволяет использовать web технологии (React, WebSockets) где они уместны
- Обеспечивает возможность обновлять содержимое без пересборки приложения
- Поддерживает двусторонний обмен данными между мобильным кодом и web содержимым

### Push Notifications

Expo Notifications обеспечивают:

- **Локальные уведомления** — срабатывают на устройстве
- **Remote notifications** — отправляются от backend сервера
- **Scheduled notifications** — уведомления запланированные на определенное время
- **Управление звуком и вибрацией** — можно кастомизировать поведение

Пользователи получают уведомления о новых сообщениях, напоминания о медицинских данных, и другие важные события.

---

## 10. Ключевые архитектурные принципы

### Offline-First

Приложение разработано с расчетом что пользователь может быть offline:

- SQLite база данных на устройстве содержит все нужные данные
- Приложение работает без интернета
- Когда интернет доступен, изменения синхронизируются с backend
- React Query управляет синхронизацией и разрешением конфликтов

### Security by Design

Безопасность встроена во все слои:

- OAuth 2.0 с PKCE для защиты от перехвата кодов
- Secure Store для хранения чувствительных данных
- Automatic token refresh предотвращает использование старых токенов
- Auto-logout при неактивности предотвращает несанкционированный доступ
- HTTPS для всех API запросов
- Request signing и validation на backend

### Scalability

Архитектура позволяет масштабировать систему:

- Backend использует микросервисную архитектуру где каждый сервис масштабируется независимо
- Kubernetes автоматически создает новые инстансы сервисов при нагрузке
- Кеширование на всех уровнях (frontend, CDN, backend) снижает нагрузку на базу данных
- Database может быть заменена на более мощную без изменения API

### Developer Experience

Архитектура оптимизирована для удобства разработчиков:

- Hot Reload позволяет видеть изменения в реальном времени
- TypeScript предотвращает целый класс ошибок на этапе разработки
- Comprehensive testing setup облегчает поддержку качества кода
- OpenAPI-генерируемые клиенты избавляют от написания HTTP boilerplate

---

## Заключение

Kii Health Mobile использует современный, проверенный stack технологий который обеспечивает:

✅ Кроссплатформенность — один код для iOS и Android  
✅ Безопасность — OAuth 2.0, PKCE, secure storage, auto-logout  
✅ Производительность — native performance, efficient caching  
✅ Надежность — Java backend, microservices, Kubernetes  
✅ Масштабируемость — независимое масштабирование сервисов  
✅ Поддерживаемость — TypeScript, clean architecture, comprehensive tests  
✅ Удобство использования — offline работа, биометрия, fast performance

Такой архитектурный выбор позволяет команде разработки быстро добавлять новые функции, безопасно масштабировать приложение при увеличении числа пользователей, и обеспечивает отличный опыт для конечных пользователей в здравоохранении.
